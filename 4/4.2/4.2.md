# 4.2. Modelo de Coordinación

# Decisiones generales del sistema
# Decisión 1 (Coordinación entre Base de Datos y Aplicación)

## Título:  
Elección de la comunicación entre la base de datos y la aplicación.

## Contexto:  
El sistema necesita una comunicación eficiente, segura y robusta entre la base de datos y la aplicación. Esta comunicación es crítica dado que se manejan datos financieros sensibles. La solución debe asegurar integridad de datos, facilidad de mantenimiento y compatibilidad con características avanzadas del motor Oracle. 

## Alternativas:

### 1. Acceso directo con JDBC puro  
- Control total sobre las consultas SQL.  
- Bajo nivel de abstracción: mayor riesgo de errores y duplicación de código.  
- Mayor esfuerzo en el manejo de recursos y transacciones.

### 2. Uso de ORM (Hibernate, JPA)  
- Simplifica el acceso a datos mediante mapeo objeto-relacional.  
- Reduce el código repetitivo y facilita el desarrollo.  
- Limitado para aprovechar características específicas de Oracle,

### 3. Uso de librerías específicas 
- Alta compatibilidad con funcionalidades propias de la base de datos.  
- Acceso optimizado a procedimientos almacenados, cursores y tipos de datos especiales.  
- Permite mayor control transaccional y mejor integración con entornos empresariales.  
- Mejora la estabilidad y el rendimiento de las operaciones críticas.

## Criterios de Elección:  
- Soporte para procedimientos almacenados y lógica PL/SQL.  
- Rendimiento, trazabilidad y estabilidad en ambientes de producción.

## Decisión:  
Se elige usar librerías específicas para la integración entre la aplicación y la base de datos.

## Sustento:  
El uso de librerías oficiales permite acceder directamente a características avanzadas del motor, mejorar el rendimiento en producción, y garantizar integridad de datos críticos. Esta solución también facilita la trazabilidad de errores y auditoría, elementos clave para aplicaciones financieras.

Esta decisión permitirá al equipo:
- Utilizar procedimientos almacenados y cursores para lógica compleja en el servidor.  
- Acceder a funcionalidades nativas de Oracle como particionamiento, triggers y replicación.  
- Optimizar el rendimiento de consultas complejas.  
- Controlar manualmente la gestión de conexiones y transacciones según necesidad.  

# Decisión 2 (Coordinación entre Módulos de la Aplicación)

## Título:  
Búsqueda de la forma de la comunicación entre los módulos de la aplicación.

## Contexto:  
La aplicación está compuesta por múltiples módulos funcionales (comprobante de pagos, gestión de invetario, CRM básico y configuración). Todos estos módulos necesitan de estar comunicados entre sí para su funcionamiento correcto.

## Alternativas:

### 1. Coordinación por llamadas directas entre módulos  
- Comunicación explícita entre clases o servicios de diferentes módulos.  
- Rápida implementación, pero genera fuerte acoplamiento y dependencia directa.  
- Dificulta pruebas, mantenimiento y evolución modular.

### 2. Coordinación mediante una interfaz de usuario modular con cargadores dinámicos  
- Cada módulo registra sus funciones en la UI mediante un descriptor o contrato.  
- La UI central puede cargar, activar o actualizar funcionalidades sin reiniciar la aplicación.  
- Permite modificar los módulos sin afectar los existentes.  
- Mejora la experiencia del usuario al tener un acceso unificado.

### 3. Coordinación basada en eventos o mensajería interna  
- Uso de un bus de eventos o sistema de mensajes (event listeners, observadores).  
- Mayor desacoplamiento, pero con mayor complejidad técnica.  

## Criterios de Elección:  
- Capacidad de modificar en tiempo real los módulos.
- Experiencia de usuario centralizada y coherente.  
- Simplicidad en el mantenimiento y evolución del sistema.

## Decisión:  
Se elige una interfaz de usuario modular y dinámica, que centraliza el acceso a los módulos y permite su actualización en tiempo real para la coordinación entre módulos.

## Sustento:  
Este enfoque permite que cada módulo registre sus funcionalidades de manera independiente dentro de una UI central. Así, la aplicación puede cargar y mostrar dinámicamente funciones según los permisos del usuario, el contexto o nuevas actualizaciones del sistema.

Esto facilita:
- La capacidad de actualizar módulos sin interrumpir el funcionamiento global.  
- Una experiencia de usuario fluida, unificada y adaptable.  
- Una base técnica para futuros módulos.
- Los despliegues, ya que afecta no afecta a la base de datos.
- Centralizar el control de navegación y permisos de acceso.  

---

# Módulo de seguridad

# Decisión 3 (Comunicación entre verificación de usuario y base de datos)

## Título:  
Elección del método de comunicación para validar credenciales de usuario con la base de datos.

## Contexto:  
La aplicación necesita autenticar a los usuarios para permitir el acceso a sus funciones. Esto requiere consultar una base de datos que almacena los datos de usuario (usuario, contraseña y roles). La solución debe ser segura, rápida y mantenerse dentro del entorno de desarrollo de la empresa.

## Alternativas:

### Comunicación mediante consultas SQL directas
- Se conecta directamente con la base de datos desde la aplicación.
- Se realiza una consulta SQL para verificar si el usuario y contraseña coinciden.
- Requiere implementar medidas de seguridad como hash de contraseñas y prevención de inyecciones SQL.

### Comunicación mediante API interna segura
- Usa una interfaz intermedia que gestiona las credenciales y valida contra la base de datos.
- Mejora la separación de capas del sistema.
- Es más segura frente a accesos no controlados, pero requiere más infraestructura.

## Criterios de Elección:  
- Bajo costo de implementación.  
- Control total dentro del sistema existente.  
- Velocidad y simplicidad en la validación.  

## Decisión:  
Se opta por el uso de consultas SQL directas para la validación de usuarios.

## Sustento:  

Las consultas SQL directas permiten validar de forma eficiente las credenciales del usuario desde la aplicación sin necesidad de una arquitectura intermedia. Esta solución requiere de medidas preventivas para evitar daños en la infraestructura por actores malígnos. Se aplicará en esta solución como hasheo de contraseñas y control de llamadas. 

### Esta decisión permitirá al equipo:
- Reducir la complejidad de la arquitectura.  
- Tener mayor control sobre la lógica de autenticación.  

---

# Módulo de CRM básico

# Decisión 4 (Almacenamiento de datos de gráficos)

## Título:  
Selección del método de almacenamiento de datos para su posterior visualización en gráficos.

## Contexto:  
La aplicación debe mostrar gráficos que representen datos financieros, operativos y de inventario. Para su posterior análisis, estos serán almacenados dentro de la base de datos.

## Alternativas:

### Almacenamiento en tablas relacionales
- Los datos se guardan en tablas normalizadas dentro de una base de datos relacional.
- Se pueden relacionar con otras entidades del sistema.
- Aumenta el costo de almacenamiento.

### Almacenamiento como imagen en un servidor cloud
- El enlace de guardado del gráfico se hará en un entorno cloud
- La consulta de este se hará por medio del llamado a su enlace
- El costo de almacenamiento es menor

## Criterios de Elección:  
- Rapidez en la consulta y renderizado de los gráficos.  
- Escalabilidad ante el crecimiento de la información.  
- Menor costo

## Decisión:  
Se opta por el almacenamiento como imagen en un servidor cloud

## Sustento:  

Al utilizar una base de datos relacional, los costos se miden por el peso de almacenamiento que se posee en estas. Por esta razón, se busca tener la mayor cantidad de datos con el menor peso posible; además, la implementaciónd de datos no estructurados hace que los costos aumenten. Al derivar las imágenes a un servidor especializado en este tipo de almacenamiento, se permitirá tener un menor costo. Este método puede ser aplicado al llamar al servidor cloud y luego pedir que nos retorne el enlace del archivo.

### Esta decisión permitirá al equipo:
- Mantener datos consistentes y fácilmente vinculables con otros módulos.  
- Escalar la solución sin necesidad de rediseñar la estructura de datos.  
- Mantener registros pasados

--- 

## Comunicación de los demás módulos con la base de datos

# Decisión 6 (Método de comunicación con la base de datos)

## Título:  
Selección del método para comunicarse y modificar los datos dentro de la base de datos.

## Contexto:  
La aplicación debe acceder y modificar datos almacenados en una base de datos. Debemos definir el método más factible para su procesamiento. La empresa busca que los métodos sean eficaces.

## Alternativas:

### Consultas SQL directas desde el frontend
- Permite conectar directamente el backend con la base de datos mediante sentencias SQL.
- Requiere protección adicional para prevenir ataques como inyección SQL.
- Es de fácil implementación y lectura.

### Comunicación mediante API intermedia
- Una API se encarga de manejar todas las solicitudes a la base de datos.
- Mejora la seguridad al aislar la base de datos del acceso directo.
- Agrega una capa de complejidad adicional en el desarrollo.

## Criterios de Elección:  
- Seguridad en el acceso a la base de datos.  
- Facilidad de implementación.  
- Rendimiento en operaciones frecuentes de lectura y escritura.

## Decisión:  
Se opta por el uso de consultas SQL directas desde el backend.

## Sustento:  

El uso de consultas SQL directas permite una implementación más sencilla, rápida y controlada dentro del entorno de desarrollo actual. Esta solución es adecuada para un sistema de mediana escala, donde el número de usuarios y el volumen de transacciones aún permiten una conexión directa sin riesgos significativos de saturación o exposición. Se establecerán buenas prácticas como el uso de consultas preparadas, validación de entrada y encriptación de credenciales para reforzar la seguridad.

### Esta decisión permitirá al equipo:
- Reducir tiempos de desarrollo y complejidad técnica.  
- Acceder a los datos de forma directa y eficiente.  
- Mantener control total sobre la lógica de las consultas.  
- Aplicar seguridad sin requerir infraestructura adicional.